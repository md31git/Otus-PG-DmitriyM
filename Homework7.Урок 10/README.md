## 1.Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
### Проверяем и меняем настройку конфигурации: включаем параметр log_lock_waits, чтобы информация по блокировкам сбрасывалась в Log и устанавливаем порог длительности блокировки для записи в log deadlock_timeout 200 миллисекунд
```Bash
sudo -u postgres psql -d db -p 5434
SHOW log_lock_waits;
SHOW deadlock_timeout;
ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM SET deadlock_timeout = 200;
SELECT pg_reload_conf();
SHOW log_lock_waits;
SHOW deadlock_timeout;
```
![image](https://github.com/user-attachments/assets/f8b69514-c63d-404f-ab3b-fd5fc38fcfa0)

### В первом соединении запускаем транзакцию и операцию на обновление записи, а затем открываем второе соединение и также в открытой транзакции пытаемся обновить ту же запись. Но т.к. у нас возникает эксклюзивная блокировка записи, то второе соединение в ожидании завершения первой и получается что у нас блокировка "висит" более 0.2 сек, пока не будет завершена/отменена первая транзакция.
В первой сессии ставим задержку 5 сек, чтобы наверняка сработал перехват блокировки в лог файл.

**1 сессия**
```Bash
begin;
update test.test set name='тест2' where id=5;
SELECT pg_sleep(5);
commit;
```
**2 сессия**
```Bash
begin;
update test.test set name='тест3' where id=5;
commit;
```
![image](https://github.com/user-attachments/assets/cebc8f81-3a12-4de8-b9b9-2dea10e0794d)

### Открываем третью сесиию для удобства и запрашиваем последние 10 строк из лог файла Postgresql. 
**3 сессия**
```Bash
sudo tail -n 10 /var/log/postgresql/postgresql-14-main3.log
```
![image](https://github.com/user-attachments/assets/77a9533b-7dc4-4724-a179-cc093c2df73d)

В лог файле видно (выделено желтым), что процесс 26381 блокировал процесс 29332 транзакцией 731  и держал 20 сек (больше 5 сек, т.к. запускались команды по отдельности).

## 2.Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.
В трех отдельных сеансах запустим последовательно обновление одной строки таблицы test.test через явное объявление транзакции (все три запроса одинаковые). Commit выполнять только после запуска в третьем сеансе обновления строки и просмотра блокировок.
```Bash
begin;
update test.test set name='тест' where id=5;
commit;
```
Просмотр блокировок будем осуществлять через следующий запрос. Выводим только нужные поля, а также убираем текущую сессию, где запускаем этот запрос, а также оставляем только блокировки отношений по таблице test.test или не блокировки отношений. 
```Bash
SELECT 
    pid, 
    locktype, 
    CASE locktype
        WHEN 'relation' THEN relation::regclass::text
        WHEN 'transactionid' THEN transactionid::text
        WHEN 'tuple' THEN relation::regclass||'('||page||','||tuple||')'
    END AS lockid,
    mode, 
    granted 
FROM pg_locks
WHERE (locktype != 'relation' OR relation = 'test.test'::regclass) and pid!=pg_backend_pid()
ORDER BY 1, 2, 3;
```

### 2.1. Обновление строки в 1 сеансе
![image](https://github.com/user-attachments/assets/d01d400f-cf9c-4bd3-bc61-8fd6e7a22369)
Мы видим три блокировки (сеанс 13149):

1.Эксклюзивная блокировка отношений RowExclusive	на таблице test.test- изменение строки.

2.Эксклюзивная блокировка номера транзакции transactionid - 752.

3.Эксклюзивная блокировка виртуального номера транзакции virtualxid. Открывается когда открыта транзакция но ни одна комнда еще не выполнена в ней, т.е. после слова BEGIN;

### 2.2. Обновление строки в 2 сеансе
![image](https://github.com/user-attachments/assets/76f30d95-6f78-4b36-9045-1037033c4931)
Мы видим 5 блокировок (сеанс 9930):

1.Три аналогичные блокировки что и в 1 сеансе (транзакция 753)

2.Разделяемая блокировка номера транзакции transactionid - 752. Эта блокировка не установлена. Она показывает что у этой транзакции намерение взять заблокированные данные транзакцией 752.

3.Эксклюзивная блокировка tuple test.test(0,13). Tuple объект появляется, когда нужно установить приоритет среди нескольких транзакций, ожидающих блокировку одной строки. Т.е. показывает что сеанс ждет освобождение строки занятой в другой транзакции.

### 2.3. Обновление строки в 3 сеансе
![image](https://github.com/user-attachments/assets/ab3040c9-33c2-4538-95ab-19a799911257)
Мы видим 4 блокировки (сеанс 9962):
1.Три аналогичные блокировки что и в 1 сеансе (транзакция 754)

2.Эксклюзивная блокировка tuple test.test(0,13). Точно такая же блокировка как и в 2 сеансе, но блокировка не установлена. Т.е. она стала в очередь после транзакции из 2 сеанса. 

Также нет разделяемой блокировки номера транзакции transactionid на 752, что означает что перва в очереди транзакция из 2 сеанса. 

Все последющие сеансы будут накладывать аналогичные блокировки чтои в 3 сеансе.

Если мы завершим транзакцию из 1 сеанса, то тогда ожидаемая команда из 2 сеанса выполниться, т.к. согласно очереди она была первой и наложит аналогичные блокировки как из 1 сеанса. В то же время все остальные сеансы (3 и далее) будут конкурировать за право стать первой транзакцией в очереди (может стать любая из любого сеанса) и "выигравший" сеанс наложит блокировка аналогичные из 2 сеанса, а "проигравшие" сеансы  наложат блокировки  аналогичны сеансу 3, только уже со ссылками на транзакцию из "выигравшего" сеанса. 




## 3.Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
## 4.Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
