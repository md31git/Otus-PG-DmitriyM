## 1.Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
Проверяем и меняем настройку конфигурации: включаем параметр log_lock_waits, чтобы информация по блокировкам сбрасывалась в Log и устанавливаем порог длительности блокировки для записи в log deadlock_timeout 200 миллисекунд
```Bash
sudo -u postgres psql -d db -p 5432
SHOW log_lock_waits;
SHOW deadlock_timeout;
ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM SET deadlock_timeout = 200;
SELECT pg_reload_conf();
SHOW log_lock_waits;
SHOW deadlock_timeout;
```
![image](https://github.com/user-attachments/assets/46e08849-aa66-468e-8b61-37c4ba70d9b1)




## 2.Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.
## 3.Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
## 4.Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
