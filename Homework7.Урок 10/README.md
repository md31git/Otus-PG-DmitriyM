## 1.Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
### Проверяем и меняем настройку конфигурации: включаем параметр log_lock_waits, чтобы информация по блокировкам сбрасывалась в Log и устанавливаем порог длительности блокировки для записи в log deadlock_timeout 200 миллисекунд
```Bash
sudo -u postgres psql -d db -p 5434
SHOW log_lock_waits;
SHOW deadlock_timeout;
ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM SET deadlock_timeout = 200;
SELECT pg_reload_conf();
SHOW log_lock_waits;
SHOW deadlock_timeout;
```
![image](https://github.com/user-attachments/assets/f8b69514-c63d-404f-ab3b-fd5fc38fcfa0)

### В первом соединении запускаем транзакцию и операцию на обновление записи, а затем открываем второе соединение и также в открытой транзакции пытаемся обновить ту же запись. Но т.к. у нас возникает эксклюзивная блокировка записи, то второе соединение в ожидании завершения первой и получается что у нас блокировка "висит" более 0.2 сек, пока не будет завершена/отменена первая транзакция.
В первой сессии ставим задержку 5 сек, чтобы наверняка сработал перехват блокировки в лог файл.

**1 сессия**
```Bash
begin;
update test.test set name='тест2' where id=5;
SELECT pg_sleep(5);
commit;
```
**2 сессия**
```Bash
begin;
update test.test set name='тест3' where id=5;
commit;
```
![image](https://github.com/user-attachments/assets/cebc8f81-3a12-4de8-b9b9-2dea10e0794d)

### Открываем третью сесиию для удобства и запрашиваем последние 10 строк из лог файла Postgresql. 
**3 сессия**
```Bash
sudo tail -n 10 /var/log/postgresql/postgresql-14-main3.log
```
![image](https://github.com/user-attachments/assets/77a9533b-7dc4-4724-a179-cc093c2df73d)

В лог файле видно (выделено желтым), что процесс 26381 блокировал процесс 29332 транзакцией 731  и держал 20 сек (больше 5 сек, т.к. запускались команды по отдельности).

## 2.Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.
В трех отдельных сеансах запустим последовательно обновление одной строки таблицы test.test через явное объявление транзакции (все три запроса одинаковые). Commit выполнять только после запуска в третьем сеансе обновления строки и просмотра блокировок.
```Bash
begin;
update test.test set name='тест' where id=5;
commit;
```
Просмотр блокировок будем осуществлять через следующий запрос. Выводим только нужные поля, а также убираем текущую сессию, где запускаем этот запрос, а также оставляем только блокировки отношений по таблице test.test или не блокировки отношений. 
```Bash
SELECT 
    pid, 
    locktype, 
    CASE locktype
        WHEN 'relation' THEN relation::regclass::text
        WHEN 'transactionid' THEN transactionid::text
        WHEN 'tuple' THEN relation::regclass||'('||page||','||tuple||')'
    END AS lockid,
    mode, 
    granted 
FROM pg_locks
WHERE (locktype != 'relation' OR relation = 'test.test'::regclass) and pid!=pg_backend_pid()
ORDER BY 1, 2, 3;
```

### 2.1. Обновление строки в 1 сеансе
![image](https://github.com/user-attachments/assets/d01d400f-cf9c-4bd3-bc61-8fd6e7a22369)
Мы видим три блокировки (сеанс 13149):
1.Эксклюзивная блокировка отношений RowExclusive	на таблице test.test- изменение строки.
2.Эксклюзивная блокировка номера транзакции transactionid - 752.
3.Эксклюзивная блокировка виртуального номера транзакции virtualxid. Открывается когда открыта транзакция но ни одна комнда еще не выполнена в ней, т.е. после слова BEGIN;

### 2.2. Обновление строки в 2 сеансе
![image](https://github.com/user-attachments/assets/76f30d95-6f78-4b36-9045-1037033c4931)
Мы видим 5 блокировок (сеанс 9930):
1.Три аналогичные блокировки что и в 1 сеансе (транзакция 753)
2.Разделяемая блокировка номера транзакции transactionid - 752. Эта блокировка не установлена. Она показывает что у этой транзакции намерение взять заблокированные данные транзакцией 752.
3.Эксклюзивная блокировка tuple test.test(0,13). Tuple объект появляется, когда нужно установить приоритет среди нескольких транзакций, ожидающих блокировку одной строки.




## 3.Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
## 4.Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
